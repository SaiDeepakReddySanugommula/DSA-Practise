/**
 * PROBLEM STATEMENT: Factor Tree of a Given Number
 * * Objective: Create a factor tree for a given input number 'v'.
 * * Logic: 
 * - The root is the input number.
 * - For any node, the left child is its smallest prime factor.
 * - The right child is the quotient (node value / smallest prime factor).
 * - This process continues for the right child until it becomes a prime number.
 * * Output: Print the level-order traversal (BFS) of the resulting tree.
 * * CONSTRAINTS:
 * - Input 'v' > 1.
 * - The leaves of the tree must all be prime factors.
 */

#include <iostream>
#include <queue>

using namespace std;

struct Node {
    int data;
    Node *left, *right;

    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};

/**
 * Recursively builds the factor tree.
 * Finds the smallest divisor starting from 2 and splits the node.
 */
void buildFactorTree(Node* root) {
    if (!root || root->data <= 1) return;

    int value = root->data;
    int smallestFactor = -1;

    // Find the smallest prime factor
    for (int i = 2; i * i <= value; ++i) {
        if (value % i == 0) {
            smallestFactor = i;
            break;
        }
    }

    // If a factor is found, the node is not prime; create children
    if (smallestFactor != -1) {
        root->left = new Node(smallestFactor);
        root->right = new Node(value / smallestFactor);
        
        // Only the right child needs further decomposition in this specific problem
        buildFactorTree(root->right);
    }
}

/**
 * Performs Level Order Traversal using a queue.
 */
void printLevelOrder(Node* root) {
    if (!root) return;

    queue<Node*> q;
    q.push(root);

    while (!q.empty()) {
        Node* current = q.front();
        q.pop();

        cout << current->data << " ";

        if (current->left) q.push(current->left);
        if (current->right) q.push(current->right);
    }
    cout << endl;
}

int main() {
    int num;
    if (!(cin >> num)) return 0;

    Node* root = new Node(num);
    
    buildFactorTree(root);
    printLevelOrder(root);

    return 0;
}
