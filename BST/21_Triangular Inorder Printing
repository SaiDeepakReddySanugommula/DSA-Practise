/*
Problem Statement:
Construct a Binary Search Tree (BST) from the given input sequence.
Print the BST nodes in a triangular form using inorder traversal such that:

Line 1: print full inorder sequence
Line 2: skip first element, print remaining inorder
Line 3: skip first two elements, print remaining inorder
...
Continue until only the last element is printed.

Constraints:
- Do NOT modify the contents of the tree.
- Do NOT use any extra arrays or additional data structures.
- Use recursion and simple logic.

Test Case:
Input:
5 3 1 2 4 8 6 7 9 -1

Output:
1 2 3 4 5 6 7 8 9
2 3 4 5 6 7 8 9
3 4 5 6 7 8 9
4 5 6 7 8 9
5 6 7 8 9
6 7 8 9
7 8 9
8 9
9
*/

#include <iostream>
using namespace std;

struct BinarySearchTreeNode {
    int data;
    BinarySearchTreeNode* leftChild;
    BinarySearchTreeNode* rightChild;
};

BinarySearchTreeNode* rootNode = NULL;

void insertIntoBST(BinarySearchTreeNode*& rootNode, int value) {
    if (rootNode == NULL) {
        rootNode = new BinarySearchTreeNode;
        rootNode->data = value;
        rootNode->leftChild = NULL;
        rootNode->rightChild = NULL;
        return;
    }
    if (rootNode->data > value) {
        insertIntoBST(rootNode->leftChild, value);
    } else {
        insertIntoBST(rootNode->rightChild, value);
    }
}

void printTriangularInorder(BinarySearchTreeNode* rootNode, int& skipCount) {
    if (rootNode == NULL) return;

    printTriangularInorder(rootNode->leftChild, skipCount);

    if (skipCount <= 0) {
        cout << rootNode->data << " ";
    }
    skipCount--;

    printTriangularInorder(rootNode->rightChild, skipCount);
}

int main() {
    int inputValue;
    int totalNodes = 0;

    while (cin >> inputValue && inputValue != -1) {
        insertIntoBST(rootNode, inputValue);
        totalNodes++;
    }

    for (int i = 0; i < totalNodes; i++) {
        int skip = i;
        printTriangularInorder(rootNode, skip);
        cout << endl;
    }

    return 0;
}
